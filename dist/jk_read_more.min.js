(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global = global || self, global.jkTextTools = factory());
}(this, (function () { 'use strict';

  // 说明：以下表述中“文章主体”不包含标题，仅正文。

  let domAction = {
    // 入口方法：获取正文文本
    autoFindText: function () {
      let me = this;

      let text_box_dom = me.findDomTextBoxArr();
      return me.getTextFromTextBoxArr(text_box_dom);
    },

    // 找到正文文本的dom容器，返回数组
    findDomTextBoxArr: function () {
      let p_doms = document.querySelectorAll("p,h1,h2,h3,h4,h5,h6,ul");

      // 预定义一个数组容器，盛放有可能是文章文本容器的dom元素
      let papas = [];
      p_doms.forEach(function (p_dom) {
        let papa = p_dom.parentElement;
        let num = parseInt(papa.p_count) || 0;
        num += 1;
        papa.p_count = num;
        papas.push(papa);
      });

      // 容错
      if (papas.length === 0) return null;

      // 循环找到最有可能为文章容器的dom元素，并于循环中赋值给papa_max
      // papa_max 为循环过程中，p_count 值最大的元素
      let papa_max = papas[0] || null;
      papas.forEach(function (papa_now) {
        if (papa_now.p_count > papa_max.p_count) papa_max = papa_now;
      });

      // 进一步优化：找到连带文章大标题的，总容器
      let big_box = papa_max;
      for (let i = 1; i <= 10; i++) {
        // 1.找到大标题，得到容器：存在H1，或仅存在1个H234（多个H234认为是系列小标题，不算找到大标题）
        if (
          big_box.querySelector("h1") ||
          big_box.querySelectorAll("h2,h3,h4").length == 1
        ) {
          break;
        }

        // 2.继续找上一层
        else if (big_box.parentElement) {
          big_box = big_box.parentElement;
        }

        // 3.没找到，停止寻找：parent.parentElement 为 null
        else {
          break;
        }
      }

      // 预定义返回结果
      let res_arr = [];

      // 结果情况1：仅有papa_box文章主体时
      if (big_box === papa_max) {
        res_arr.push(big_box);
      }
      // 结果情况2：找到 总容器 以内的，正文容器（papa_max）和之前的容器：便于舍弃正文之后的内容
      else {
        // 子容器
        let big_box_children = big_box.children;
        // 首次出现标题的容器index
        let index_title = null;
        // 文章主体的容器index
        let index_papa_max = null;

        // 标题
        let ele_title = big_box.querySelector("h1,h2,h3,h4");

        for (let key in big_box_children) {
          // 转换key为index，便于计算起始位置
          let index = parseInt(key);
          if (isNaN(index)) continue;

          let item = big_box_children[index];

          // 明确标题 index
          if (item.contains(ele_title)) {
            index_title = index;
          }
          // 明确文章主体 index
          if (item.contains(papa_max)) {
            index_papa_max = index;
          }

          // 获取 标题 到 文章主体 各dom
          if (index >= index_title && index <= index_papa_max) {
            res_arr.push(item);
          }

          // 适当获取 文章主体 后一个dom的内容（可能为页脚，包含编辑人员信息）
          if (index === index_papa_max + 1 && item.innerText.length <= 250) {
            res_arr.push(item);
          }
        }
      }

      // 返回dom
      return res_arr;
    },

    // 获取文本(从数组，dom 为数组元素)
    getTextFromTextBoxArr(dom_box_arr) {
      let me = this;

      // 容错
      if (!dom_box_arr || dom_box_arr.length === 0) {
        return "遗憾：该页面未发现文章";
      }

      let text = "";
      dom_box_arr.forEach(function (item) {
        let text_sec = me.getTextFromTextBox(item);
        if (text_sec) text += text_sec + "\n\n";
      });

      // 容错
      if (text.length <= 100) {
        return "遗憾：该页面未发现文章";
      }

      return text.trim();
    },

    // 获取文本(从单个dom)
    getTextFromTextBox(dom_box) {
      // 如果没有子标签，则直接返回文本（如独立 H1 标签，没有被包裹的容器时）
      if (!dom_box.children[0]) return dom_box.innerText + "\n\n";

      // 正常情况：

      let str_selector = "p,h1,h2,h3,h4,h5,h6,ul";
      let p_doms = dom_box.querySelectorAll(str_selector);

      let text = "";
      p_doms.forEach(function (p_dom) {
        let p_text = "";
        p_text = p_dom.innerText;

        // 优化：清理分享按钮
        if (
          p_dom.tagName === "UL" &&
          p_dom.getAttribute("class").indexOf("share") >= 0
        ) {
          p_text = "";
        }

        // 无字有图的情况，取图
        if (!p_text && p_dom.querySelector("img")) {
          let imgs = p_dom.querySelectorAll("img");
          let img_src_text = "";
          imgs.forEach(function (item) {
            img_src_text += ` ${item.src}`;
          });
          p_text += `([*配图:${img_src_text}])`;
        }

        // 累加
        if (p_text.trim() !== "") {
          text += p_text + "\n\n";
        }
      });

      return text;
    },
  };

  let wordsRepeated = {
    // ###########################
    // 以下为主方法
    autoRun(text) {
      let me = this;

      // 预处理文本
      text = me.preSetText(text);

      // 配置初始数据
      me.data.text = text;
      me.data.text_remain = text;
      me.data.res_temp = {};
      me.data.num_loop_count = 0;

      // 优化配置
      if (text.length <= 200) {
        me.cfg.num_on_recognize = 2;
      } else if (text.length >= 1000) {
        me.cfg.num_on_recognize = 4;
      }

      // 循环取词
      me.mainLoop();

      // 返回数据
      return me.formatRes();
    },

    // 循环首位取词和调整text_remain的方法
    mainLoop() {
      let me = this;

      // 清空首位符号
      for (let item of me.marks.char_split) {
        if (me.data.text_remain.indexOf(item) === 0) {
          me.data.text_remain = me.data.text_remain.replace(item, "");
        }
      }

      // 取得文本段0位首词，或 ''
      let head_word_expected = me.getHeadWord();

      // 判断 text_remain 文本处理完毕，循环结束
      if (me.data.text_remain.length === 0) {
        return;
      }

      // 如果未取到0位首词，text_remain 去除首位字符，继续投入循环
      if (!head_word_expected) ;
      // 如果取到了0位首词，记录该词
      else {
        // 记录
        if (!me.data.res_temp[head_word_expected]) {
          if (me.cfg.dev_on_log)
            console.log("%c ▶ 新 word: " + head_word_expected, "color: #185;");

          let count = me.data.text.split(head_word_expected).length - 1;
          me.data.res_temp[head_word_expected] = count;
        } else {
          if (me.cfg.dev_on_log)
            console.log("%c ▶ 旧 word: " + head_word_expected, "color: #185;");
        }
      }

      // 核心操作：剩余文字存储
      // 注意，这里必须要 “- 1”，多留出上一个字符的判断（汉语断句问题）。
      let index_restart = me.data.on_head_string.length - 1;
      index_restart = index_restart >= 1 ? index_restart : 1;
      me.data.text_remain = me.data.text_remain.substr(index_restart).trim();

      // 继续循环查找
      me.mainLoop();
    },

    // 格式化输出
    formatRes() {
      let me = this;

      let arr = [];
      for (let key in me.data.res_temp) {
        let num_count = me.data.res_temp[key];

        let item = {
          word: key,
          count: num_count,
          weight: num_count * (key.length >= 7 ? 7 : key.length),
        };
        arr.push(item);
      }

      return arr.sort((a, b) => b.weight - a.weight);
    },

    // 预处理传入文本
    preSetText(text) {
      // 清除如 "([*插图： ...])"" 类插入类的文本
      let reg_texx_inserted = /\(\[\*(.*?)\]\)/g;
      let res = text.replace(reg_texx_inserted, "");
      return res;
    },

    // ###########################
    // 以下为数据和配置等

    // 数据记录部分
    data: {
      // 全文
      text: "",
      // 剩余文本
      text_remain: "",
      // 最近一个被检查的0位string，用于 mainloop 结束时抹除首位
      on_head_string: "",
      //
      on_head_line: "",

      // 结果暂存，词汇计数用，如 {'我们': 3}
      res_temp: {},

      // loop_count
      num_loop_count: 0,
    },

    // 标记符号和标点
    marks: {
      char_split: [
        ", ",
        ". ",
        ": ",
        "? ",
        "! ",
        "、",
        "，",
        "。",
        "：",
        "？",
        "！",
        "~",
        "——",
        //Tab符
        "	",
        "#",
        "\n",
      ],
      char_quote: {
        "‘": "’",
        '"': '"',
        "“": "”",
        "<": ">",
        "《": "》",
        "「": "」",
        "『": "』",
        "[": "]",
        "【": "】",
        "(": ")",
        "（": "）",
      },
    },

    // 配置部分
    cfg: {
      // 达到识别取词的重复次数
      num_on_recognize: 3,
      // 循环取词时，拟定的单词的最长长度、最短长度（汉语词一般2~7长度，网址等可能50长度，暂定50）
      length_word_max: 50,
      length_word_min: 2,
      // 达到粘合识别的空格比例，英语的话基本在 0.08 ~ 0.16 区间
      num_space_rate: 0.08,

      //
      dev_on_log: false,
    },

    // ###########################
    // 以下为工具类方法

    // 获取字符串开头的单词
    getHeadWord() {
      let me = this;

      // 获取首句 text.
      let text_head_line = me.getHeadLine(me.data.text_remain);

      // 获取首句空格率
      let num_space_rate = me.calcSpaceRate(text_head_line);

      // 00情况：如果该句开头已经匹配了已有词汇，则跳过
      if (me.getHeadWord_subFunction_headWordChecked()) {
        return "";
      }

      // 01情况：如果该句已经只剩1个字符，如text_remain为“的，我们才...”时，则直接返回'',来跳过该字符
      if (text_head_line.length <= 1) {
        return "";
      }

      // 02情况：如果开头是数字（如：2012年... 、1000万人口...）：整个数字取出
      else if (me.matchHeadNumber(text_head_line)) {
        let num_temp = me.matchHeadNumber(text_head_line);

        // 记录
        me.data.on_head_string = num_temp;

        // 如果小于3个字符，则放弃该单词（如she he and for）
        if (num_temp.length <= 3) return "";

        return me.getHeadWord_subFunction_verifyWord(num_temp);
      }

      // 03情况：如果空格出现频繁（如英语时），按照空格断词：取第一个空格之前的文本为 headword
      else if (num_space_rate >= me.cfg.num_space_rate) {
        let head_str = text_head_line.substr(0, text_head_line.indexOf(" "));

        // 记录
        me.data.on_head_string = head_str;

        // 如果小于3个字符，则放弃该单词（如she he and for）
        if (head_str.length <= 3) return "";

        return me.getHeadWord_subFunction_verifyWord(head_str);
      }

      // 04情况：否则循环取词（如汉语时）
      else {
        let max = me.cfg.length_word_max;
        let min = me.cfg.length_word_min;

        // 拟定返回值
        let res_str = "";

        for (let i = min; i <= max; i++) {
          // ↑ i 在这里代表取词length
          let head_str = text_head_line.substr(0, i);
          
          // 记录
          me.data.on_head_string = head_str;

          // 【如果】向后粘合，跳过本次首词判断，继续向后
          let str = text_head_line.charAt(i - 1) + text_head_line.charAt(i);
          let reg_sticky_eng = /^[A-Za-z]+$/;
          let reg_sticky_num = /^[0-9]+$/;
          if (reg_sticky_eng.test(str) || reg_sticky_num.test(str)) {
            continue;
          }

          // 进行常规判断
          if (me.getHeadWord_subFunction_verifyWord(head_str)) {
            res_str = head_str;

            // 单词已经扩大到句尾，则停止循环
            if (res_str === text_head_line) break;
          } else {
            break;
          }
        }

        return res_str;
      }
    },
    getHeadWord_subFunction_verifyWord(str_expected) {
      // 此方法计算 str_expected 在 text_remain 中的数量，达到数量返回 str_expected，否则返回空

      let me = this;

      // 循环统计计数
      me.data.num_loop_count += 1;

      // 容错
      if(!str_expected || str_expected.trim().length <2){
        return ''
      }

      let reg_head_str = new RegExp(me.transStringForReg(str_expected), "g");
      let num_repeated = me.data.text.match(reg_head_str)
        ? me.data.text.match(reg_head_str).length
        : 0;

      // log
      if (me.cfg.dev_on_log) {
        console.log(
          "fn verifyWord - reg_head_str: " +
            reg_head_str +
            ", num_repeated: " +
            num_repeated +
            (num_repeated >= me.cfg.num_on_recognize ? ", try next" : ", stoped")
        );
      }

      // 返回
      if (num_repeated >= me.cfg.num_on_recognize) {
        return str_expected;
      } else {
        return "";
      }
    },
    getHeadWord_subFunction_headWordChecked() {
      // 返回句首已存在的词，或者 ''
      let me = this;
      let res = "";
      for (let key in me.data.res_temp) {
        if (me.data.on_head_line.indexOf(key) === 0) {
          res = key;

          // 记录
          me.data.on_head_string = key;

          break;
        }
      }
      return res;
    },

    // 获取字符串的首句（根据第一次出现的断句标点符号）
    getHeadLine(text) {
      let me = this;

      // 默认最多读取100位
      let index = 100;

      for (let i in text) {
        i = parseInt(i);

        if (i >= 20) break;

        let char1 = text.charAt(i);
        let char2 = text.charAt(i) + text.charAt(i + 1);

        let arr_char_split = me.marks.char_split;
        let arr_char_quote = [];
        for (let key in me.marks.char_quote) {
          arr_char_quote.push(key);
          arr_char_quote.push(me.marks.char_quote[key]);
        }

        // 找到最近的 char_split 字符，作为断句index。
        if (
          arr_char_quote.indexOf(char1) >= 0 ||
          arr_char_split.indexOf(char1) >= 0 ||
          arr_char_split.indexOf(char2) >= 0
        ) {
          index = i;
          break;
        }
      }

      let res = text.substr(0, index);

      if (me.cfg.dev_on_log) console.log("fn getHeadLin output: " + res);

      return res;
    },

    // 计算一段文字的空格率。（一般用于首句的空格率检查，根据空格率取首词）
    calcSpaceRate(text) {

      // 容错，避免出现length长度为0的分母
      text = text || "_";

      let reg_space = / /g;
      let arr_match = text.match(reg_space) || [];
      let current_space_rate = arr_match.length / text.length;

      return current_space_rate;
    },

    // 匹配取出开头的字符串，给 getHeadWord() 使用
    matchHeadNumber(text) {
      // reg_num: 数字、数字ip地址等，均可匹配
      let reg_num = /^\d+([\.,-]\d+)*/;
      let match = text.match(reg_num);
      if (match) {
        return match[0];
      } else {
        return "";
      }
    },

    // ###########################
    // 以下为更基础类的工具类方法
    transStringForReg(str) {
      let res = str;
      let marks = "\\^$.*+?()[]{}|";
      marks = marks.split("");
      for (let i in marks) {
        let mark = marks[i];
        let reg = new RegExp("\\" + mark, "g");
        res = res.replace(reg, "\\$&");
      }
      return res;
    },
  };

  // main.js

  const jkTextTools = {
    _info: {
      v: 1.0,
    },
    _tools: {
      domAction,
      wordsRepeated,
    },

    getWordsFromText(text) {
      return wordsRepeated.autoRun(text);
    },

    getPageArticleText() {
      let text = domAction.autoFindText();
      return text;
    },
    getPageArticleWords() {
      let text = domAction.autoFindText();
      let arr = wordsRepeated.autoRun(text);
      return arr;
    },
  };

  return jkTextTools;

})));
